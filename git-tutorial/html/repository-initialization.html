<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8" />
	<title>Git Tutorial</title>
	<link rel="stylesheet" type="text/css" href="../css/git-tutorial.css" />
</head>
<body>
  <content>
  	<h1>Git Tutorial - 3. Repository Initialization</h1>
    <navigation>
      <a href="../git-tutorial.html">1. Home</a>
      <a href="git-installation.html">2. Git Installation (windows)</a>
      <a href="repository-initialization.html">3. Repository Initialization</a>
      <a href="repository-contents-post-init.html">4. Repository Contents Post-Init</a>
      <a href="first-commit.html">5. First Commit</a>
      <a href="repository-contents-post-commit.html">6. Repository Contents Post-Commit</a>
      <a href="branches.html">7. Branches</a>
      <a href="rebase.html">8. Rebase</a>
      <a href="merge.html">9. Merge</a>
      <a href="synching.html">10. Synching</a>      
      <a href="cheat-sheet-command-line-interface.html">Cheat Sheet - Command Line Interface</a>
      <a href="cheat-sheet-git.html">Cheat Sheet - Git</a>
      <a href="cheat-sheet-git2.html">Cheat Sheet - Git#2</a>
      <a href="cheat-sheet-vi-editor.html">Cheat Sheet - Vi Text Editor</a>
    </navigation>

    <gitbash>
      <h2>Run Git Bash</h2>
      <img src=../img/run-gitbash.png />
      <h2>Navigate to Desktop & Create a Project Directory</h2>
      <vertical-pile>
      <img src="../img/navigate-to-desktop.png" />
      <span>
        <ul>
          <li class="help">You may skip the directory creation via the Git Bash terminal window, just make sure you are in the right directory, before adding a directory to revision control later on.</li>
          <li><span class="semi-bold blue">pwd</span> - shows current location in the file system.</li>
          <li><span class="semi-bold blue">cd Desktop</span> - changes location from current directory "C:\Users\YourUserName" to subdirectory "Desktop".</li>
          <li><span class="semi-bold blue">mkdir magic-boomerang</span> - creates a new directory named "magic-boomerang" on the current directory (Desktop).</li>
          <li><span class="semi-bold blue">cd magic-boomerang</span> - changes location from current directory "C:\Users\YourUserName\Desktop" to subdirectory "magic-boomerang".</li>
        </ul>
      </span>
      </vertical-pile>

      <h2>Set Username and Email <span class="help">(one time config for every OS user account)</span></h2>
      <vertical-pile>        
      <img src="../img/configuration.png" />
      <ul>
        <li>The config file is saved as .gitconfig -file at user's home directory and its contents are as follows:</li>
        <li>
<pre>
[user]
  name = Jarno Poikonen
  email = reactionstack@gmail.com
[core]
  autocrlf = true <span class="help">(this was set by installation wizard earlier)</span>
</pre>
        </li>
      </ul>
      </vertical-pile>

      <span class="semi-bold blue"><h2>Git Command: git help</h2></span>
      <vertical-pile>
      <img src="../img/git-help.png" />
        <ul><h3>For those unfamiliar with command line API description syntax characters:</h3>
          <li>Double dash <span class="semi-bold blue">--</span>, denotes an option, in verbose form, usually a whole word.</li>
          <li>Single dash <span class="semi-bold blue">-</span>, denotes an option, in shorthand form, usually a single letter.</li>
          <li>Single dash between words without any bounding spaces is just a literal dash between words.</li>
          <li>Therefore <span class="semi-bold blue">git --help</span>, means that the git.exe accepts a string input of <span class="semi-bold blue">"--help"</span>, which git interprets as a command to print helpful text to the standard output (terminal/command prompt/what-have-you).</<li>
          <li>Text within angle brackets <span class="semi-bold blue">&#60text&#62</span> denotes a mandatory string input argument.</li>
          <li>Text within square brackets <span class="semi-bold blue">[text]</span> denotes an optional string input argument.</li>          
          <li>Vertical bar <span class="semi-bold blue">|</span>, stands for "or", for example: <span class="semi-bold blue">git [-p | --paginate | -P | --no-pager]</span> means that git accepts either <span class="semi-bold blue">--paginate</span> or <span class="semi-bold blue">--no-pager</span> options or their shorthanded forms of <span class="semi-bold blue">-p</span> or <span class="semi-bold blue">-P.</span></li>
          <li>Pretty much everything else is to be taken literally.</li>
          <li>When in doubt, just google it.</li>
          <h3>Some Examples:</h3>
          <li><span class="semi-bold blue">git</span>,        brings out the help text as shown on the left.</li>
          <li><span class="semi-bold blue">git --help</span>, brings out the help text as shown on the left.</li>
          <li><span class="semi-bold blue">git help</span>,   brings out the help text as shown on the left.</li>
          <li><span class="semi-bold blue">git help help</span>, brings out the help manual in your browser.</li>
          <li><span class="semi-bold blue">git help init</span>, brings out the init manual in your browser.</li>
          <li><span class="semi-bold blue">git help -h</span>, shows the available options for <span class="semi-bold blue">help</span> in the standard output.</li>
          <li><span class="semi-bold blue">git init -h</span>, shows the available options for <span class="semi-bold blue">init</span> in the standard output.</li>
          <li><span class="help">Remember <span class="semi-bold blue">git help &#60command&#62</span> and <span class="semi-bold blue">git &#60command&#62 -h</span>, they are very useful.</span></li>
        </li></ul>
      </vertical-pile>

      <span class="semi-bold blue"><h2>Git Command: git init</h2></span>
      <vertical-pile>
        <img src="../img/git-init.png" />
        <ul><li>By first calling <span class="semi-bold blue">git help</span>, git shows a list of the most common commands, where one is named as <span class="semi-bold blue">init</span> with a description next to it saying: "Create an empty Git repository or reinitialize an existing one".</li>
          <li>Then one can call <span class="semi-bold blue">git init -h</span> to view <span class="semi-bold blue">init's</span> shortened documentation and if necessary even call <span class="semi-bold blue">git help init</span> to view the <span class="semi-bold blue">init's</span> full documentation in browser.</li>
          <li><span class="semi-bold blue">init</span> requires no parameters, so one can just call <span class="semi-bold blue">git init.</span></li>
          <li>Now the directory and its future subdirectories and their files will all be under revision control of git.</li>
          <li>By enabling view hidden items you can verify git actually created its repository files into a directory named <span class="semi-bold blue">.git.</span></li>
          <li>This directory is the git repository, which will serve as the local database for all the working directory snapshots of magic-boomerang.</li>
          <li><img src="../img/show-hidden-items.png" /></li>
        </ul>
      </vertical-pile>

      <vertical-pile>
        <img src="../img/verify-repo-existence.png" />
        <ul>
          <li>Alternatively one can call <span class="semi-bold blue">ls -a</span> in git bash to view all the files in the current directory including hidden files like the .git directory. <span class="semi-bold blue">ls</span> is a unix command that lists common files in the current path to standard output, the <span class="semi-bold blue">-a</span> option stands for "all" which tells the <span class="semi-bold blue">ls</span> to view the hidden files as well.</li>
        </ul>
      </vertical-pile>

      <vertical-pile>
        <img src="../img/not-an-ordinary-directory.png" />
        <ul>
          <li>Since the magic-boomerang directory is now under revision control of git, git bash shows the branch name of the repository <span class="semi-bold blue">(master)</span>, indicating that the user of the git bash is now in a directory that has a repository, a repository whose current branch is master.</li>
        </ul>
      </vertical-pile>
    </gitbash>
    <footer></footer>
  </content>  
  <script src=../js/init-repository.js></script>
</body>
</html>
          <!--          
          <p>
            <li>The git repository (the hidden .git directory) is just a simple database.</li>
            <li>The git repository stores a snapshot as its records on every commit.</li>
            <li>Snapshots </li>
            <li>Conceptually a snapshot is a list of files that should be restored to the working directory from the repository when user tells git to do so. </li>
            <li>Technically snapshot is a list of pointers that point to stored files in the repository. If any two files differ in name and content, those files have unique pointers to them.</li>

            <li>Technically, snapshot</li>
            <li>The committed files are stored as git objects: blobs, trees, tags and a single commit object.</li>
          </p>
          <p>
            <li>The list of files is called the index file.</li>
            <li>To commit an index file call <span class="semi-bold blue">git commit -m &#60UserMessage&#62.</span></li>
            <li>Filepaths must be added to the index file before a commit can be made.</li>
            <li>To add filepaths to the index file call <span class="semi-bold blue">git add &#60FilePath&#62.</span></li>
            <li>Only new files and modified files since last commit are addable to the index file.</li>
            <li>To view if a file is new or modified call <span class="semi-bold blue">git status</span> or <span class="semi-bold blue">git status -s.</span></li>
          </p>
          <p>
            <li>All stored git objects are compressed by the zlib compression library.</li>
            <li>A 40-character long hexadecimal SHA-1 hash is created based on the git objects to be stored.</li>
            <li>A filepath is created from the hash at .git/objects/{first-2-hexadecimal-digits}/{the-remaining-38-hexadecimal-digits} with no file extension.</li>
            <li>The contents of this filepath is the git objects as they were created from the index file.</li>
            <li>The idea behind hashing the filepaths is to ensure that the filepaths would work as unique keys to values since git repositories are simple key-value storage databases. The stored content is the value, and the generated hash is the key.</li>
            <li>The reason why git uses two digits of the hash to create a folder is because at the time git was first introduced in 2005, common file systems at the time were often limited to 65536 files per directory. Even for NTFS -file systems (Windows) this many files in a single directory meant slow performance.</li>
          </p>

          <h3>Git Objects</h3>
          <p>Git stores 4 types of data in the .git/objects directory at the time user commits an index file:</p>
          <p>
            <li>Blob objects store the content portion of committed files, but not their filenames or filepaths.</li>
            <li>Tree objects store the filepaths and filenames of blobs and possibly other trees, called subtrees.</li>
            <li>Commit object stores a pointer to the root tree of the tree objects and one pointer for every parent commit object. </li>
            <li>Tag objects are just named references that point to commit objects. Use of tags removes the need to remember 40-character long hexadecimal strings.</li>
          </p>
          <p>
            <li>Via root tree, git restores the files that were committed at this commit.</li>
            <li>Via commit's parent pointers, git is able to traverse through the commit history.</li>
            <li>Commit history grants access to the root trees in prior commits which allows git to restore the files of those commits too, but only the most up to date versions of files are restored up to the chosen commit.</li>
          </p>

          <h3>Working Tree</h3>
          <p>
            <li>Working tree is a working directory, a single working space that is watched for changes by the repository.</li>
          </p>
          <p>
            <li>There can be zero to many working trees per repository.</li>
            <li>Bare repositories start with zero working trees.</li>
            <li>Repositories initialized with <span class="semi-bold blue">git init</span> or <span class="semi-bold blue">git clone</span> start with one working tree called the main working tree.</li>
            <li>Additional working trees can be created by calling <span class="semi-bold blue">git worktree add &#60DirectoryPath&#62</span>, these are called linked working trees.</li>
          </p>
          <p>
            <li>The root directory of the main working tree is the same directory the hidden .git directory is in.</li>
            <li>The root directory of the linked working tree is the directory path given by the user.</li>
          </p>
          <p>
            <li">Great place to store the linked working trees is inside the .git directory.</li>
          </p>

          <p>
            <li>Use of additional working trees simplifies workflow.</li>
            <li>By creating additional working trees user is able to work on multiple branches simultaneously without resorting to <span class="semi-bold blue">git checkout &#60BranchName&#62</span> repeatedly.</li>
          </p>

          

          <h3>Snapshots</h3>
          <p>
            <li>Snapshots are made of git objects. </li>
            <li>After first commit, git shall </li>
            <li>Reconstruc.</li>
            <li>New snapshot is the to-be-committed changes.</li>
            <li>Committed working tree may differ from the actual working tree state due to using of .ignore file that tells the git repository to ignore certain file or maybe the user did not stage some of the changes to the snapshot commit.</li>
          </p>
          <p>
            <li>Snapshots are made of trees and blobs, tracked by commit object:</li>
            <li class="disc-list">Trees remember the structure and names of directories and files, but not their content.</li>
            <li class="disc-list">Blobs remember the content of files, but have no memory of their location or filename.</li>
            <li class="disc-list">Commit object has a pointer to the root tree, and another pointer to its parents from previous commits. Parent pointer enables access to snapshot history, pointer to root trees enables restoring any working tree state in the snapshot history.</li>
          </p>
          <p>
            <li>At the time of commit a 40-character long SHA-1 hash is encoded from the contents of the snapshot to form a unique key.</li>
            <li>Contents that affect the hashing algorithm are:</li>
            <li class="disc-list">root tree</li>
            <li class="disc-list">parent commit SHA-1</li>
            <li class="disc-list">name of the author</li>
            <li class="disc-list">name of the committer</li> 
            <li class="disc-list">commit message</li>
          </p>
          <p>
            <li>This unique key will be used as an address to access the stored snapshot.</li>
            <li>The filepath ("address") to the stored snapshot would be: 
            .git/objects/{first-2-hexadecimals-of-hash}/{the-remaining-38-hexadecimals-of-hash}.</li>
            <li>Point of hashing is to create unique filepaths, the stored snapshot itself is only converted to trees and blobs and then compressed.</li>
            <li>Git uses zlib compressing library to store all the committed snapshots.</li>
          </p>
          
          <h3>Staging, Index File, Cache</h3>
          <p>
            <li>User has the power to select the changes he wants to commit to a snapshot. The changes that took place in the working tree due to user modifying files, creating new files, deleting files, renaming files.</li>
            <li>Selection happens by adding files with changes to a list called index file.</li>
            <li>Adding files to the index file is called staging.</li>
            <li>Adding files to the index file causes that file to become tracked by git.</li>
            <li>Removing files from the index file is called unstaging.</li>
            <li>Index file is also called cache by some of the git commands and their documentation.</li>
          </p>

          <h3>Viewing changes</h3>
          <p>
            <li>To view the changes in the working tree (the addable files to the index file) can be queried by calling git status.</li>
            
            
          </p>

          <h3>Adding changes</h3>
          <p>
            <li>Staging of file is done by calling git add &#60FilePath&#62.</li>
          </p>

          <h3>Removing changes</h3>
          <p>
            <li>
              git rm --cached &#60FilePath&#62
            </li>
          </p>

          <h3>Ignoring changes</h3>
          <p>
            <li>
              
            </li>
          </p>

          <h3>Committing changes</h3>
          <p>
            <li>To confirm the wanted changes one calls git commit -m &#60CommitMessage&#62. <button id="toggle-view-button" onclick="toggleView()">Show more...</button><span class="help toggle-hideable">If you followed the installation guide to the letter, calling <span class="semi-bold blue">git commit</span> would open the default text editor, vim, in terminal. Google up instructions for setting up your favorite text editor in git. If by accident you open the vim in terminal, CTRL+Z, should get you out.</span></li>
          </p>
          

          <h3>Snapshot, Hash, Commit - virtually the same thing</h3>
          <p>
            <li>Snapshots are stored as blobs and trees behind a filepath that is encoded as a 40-character long hexadecimal SHA-1 hash (e.g. 24b9da6552252987aa493b52f8696cd6d3b00373).</li>
            <li>Where the first 2 hexadecimals is the directory name in .git/objects/, and the remaining 38 hexadecimals for the filename. The content of the file is the stored snapshot as trees and blobs all stored in binary form.</li>
            <li>Hash is generated from an index of files that was committed by a user.</li>
            <li>A hash can be used to generate the original files with their file structure intact by using the hash as key.</li>
            <li>Hashes are often called commits.</li>
            
          </p>


          <h3>Common Workflow</h3>
          <p>
            <li>1) Cause change in the working tree by modifying, creating or deleting a file. (deleted files are treated as modified)</li>
            <li>2) Add files with change to the index.</li>
            <li>3) Commit the index.</li>
            <li>4) Repeat 1-3, until something more special is required.</li>
          </p>


          <h3>Committing</h3>
          <p>
            <li>Adding files to the index is done by calling <span class="semi-bold blue">git add &#60FileName&#62</span>.</li>
          <li>Valid filenames are those that git can see, i.e. the files in the working tree.</li> 
          <li>Adding of a file to the index causes git repository to track that file indefinitely.</li>
          <li>Only new files or modified files are addable to the index.</li>
          <li>To find the filenames that are addable to theindex, call <span class="semi-bold blue">git status</span>.</li>
          <li>Committing an index is done by calling <span class="semi-bold blue">git commit -m &#60UserMessage&#62</span>. <button id="toggle-view-button" onclick="toggleView()">Show more...</button><span class="help toggle-hideable">If you followed the installation guide to the letter, calling <span class="semi-bold blue">git commit</span> would open the default text editor, vim, in terminal. Google up instructions for setting up your favorite text editor in git. If by accident you open the vim in terminal, CTRL+Z, should get you out.</span></li></p>


          <h3>Branches</h3>
          <p><li>Every <span git repository</span> starts with a <span master branch</span> which gets initially selected as it is the only one.</li>
          <li><span Checkout branch</span> is the branch the user has selected with the git command, <span class="semi-bold blue">git checkout &#60BranchName&#62</span>.</li> 
          <li>Additional <span branches</span> can be created, be named and be <span checkout</span> to.</li></p>

          
          <h3>HEAD</h3>
          <p><li><span HEAD</span> is a reference that usually points to the topmost <span commit</span> of the current <span checkout branch</span>.
          </li>
          <li><span HEAD</span> can point to any <span commit</span>, and when it does, it is called a <span detached HEAD</span>.</li>
          <li>By convention all capital "HEAD" refers to current head, while just "head" refers to any named head in the repository</li></p>

          
          <h3>Tracking</h3>
          <p><li><span Working tree</span> can have three kinds of files: <span ignored, untracked</span> and <span tracked</span> by git.</li>
          <li class="disc-list"><span Ignored</span> files will not be shown ..</li>
          <li class="disc-list"><span Untracked</span> files will have their filenames shown in red ..</li>
          <li class="disc-list"><span Tracked</span> unmodified files will not be shown ..</li>
          <li class="disc-list"><span Tracked</span> modified files will have their filenames shown either in green or red ..</li>
          <li>.. in the standard output when calling <span class="semi-bold blue">git status</span> in the <span working tree</span>.</li></p>

          
          <h3>git status</h3>
          <p><li><span class="semi-bold blue">git status</span> displays filenames that have comparison differences between</li> 
          <li class="disc-list"><span HEAD</span> and <span index</span></li>
          <li class="disc-list"><span index</span> and <span working tree</span></li>
          <li class="disc-list"><span working tree</span> and <span untracked</span> files</li>
          <li> but <span ignores</span> the files that are marked to be <span ignored</span> in a .gitignore -file. </li>
          <li>Unchanged files are not displayed by <span class="semi-bold blue">git status</span>.</li> </p>

          
          <h3>git status colors</h3>
          <p><li>After calling <span class="semi-bold blue">git status</span>, green color in a filename indicates that the <span index</span> has been updated with a previously modified <span tracked</span> file which is now <span commitable</span>.</li>
          <li>Red color in a filename may indicate two different causes:</li>
          <li class="disc-list">The file is a <span tracked</span> file, which got modified.
          <li class="disc-list">The file is an <span untracked</span> file, which got introduced to the <span working tree</span>.</li>
          <li> While red, the file is not <span commitable</span> via <span index</span> yet, but it is <span addable</span> to the <span index</span>.</li> 
          <li>Calling <span class="semi-bold blue">git add &#60FileName&#62</span> on a modified or new filename will turn the filename from red to green indicating that the file has been reviewed by the user, is up to date in the <span index</span>, and is now <span commitable</span> as a <span snapshot</span> to the <span git repository</span>.</li></p>

          
          <p><li>To make git ignore certain types of files or individual files, user may create a filenamed .gitignore in the working tree. Then the user may write line-by-line -entries in .gitignore for the names of files that should be ignored. (for example: *.exe, would cause git to ignore all executables)</li></p>


          

          

      </ul>
      </vertical-pile>
      <span class="semi-bold blue"><h2>Git Command: git status</h2></span>
      <vertical-pile>
        <img src="../img/git-status-no-commits-yet.png" />
        <ul>
          <li>By calling git status, git will first compare the differences in paths with HEAD commit and the index file, then between the index file and the working tree, then between the working tree and the untracked files.</li>
        <!--
          <li>Again one can call <span class="semi-bold blue">git help</span> for aid, but from now on those   calls are omitted in this tutorial. Next vital command in question is <span class="semi-bold blue">git status</span>.</li>
          <li>But before jumping into git status, a three key components of git must be explained.</li>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
          <li>By calling <span class="semi-bold blue">git status</span>, git tells the user the status of the working tree compared to an index file, and the status of the index filewhere working tree is the current directory and its content, and index is the current snapshot of the repository. Think of it like this: repository is first empty, the index remembers that it is emptyif one were to add new files in the magic-boomerang repository, git status would show those new filenames as changes that differ from the current repository snapshot, which initially was empty. This change is detected by git, when git  component called index</li>
          <li><span class="help">Create a Hello_World.txt with the sentence "Hello World! on the first line with your favorite text editor and save the file into the magic-boomerang repository. To be clear: one is not supposed to put any files in the .git directory, but in the same directory where the .git directory is in.</span></li>
        -->
